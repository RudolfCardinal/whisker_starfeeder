Whisker starling weighing function with RFID tagging

===============================================================================
DATABASE INTERFACE
===============================================================================
- we want schema management to be easy for the user
- therefore, let's use a proper system: SQLAlchemy
- Database:
    ?Access (but it is rubbish)
    ?SQlite
        ... SQLiteStudio looks like a good native explorer

===============================================================================
ALEMBIC: migrations
===============================================================================
- http://alembic.readthedocs.org/en/latest/index.html

- What follows runs from the project base directory.
- make framework with
    $ alembic init alembic
- edit alembic.ini to set SQLite URL
- edit alembic/env.py to set target_metadata
    from weigh.weigh import Base
    target_metadata = Base.metadata
- make an autogenerated revision
    $ alembic revision --autogenerate -m 'some message'
- upgrade database
    $ alembic upgrade head

- make a revision with a specified ID
    $ alembic revision --autogenerate -m 'some message' --rev-id 6

===============================================================================
CONFIGURATION FILES
===============================================================================

- Alembic uses its alembic.ini file for the database URL. Not great. Fixable.
    http://stackoverflow.com/questions/22178339/is-it-possible-to-store-the-alembic-connect-string-outside-of-alembic-ini
    ... can change that in env.py
- Alembic can't get rid of a column in SQLite; it tries DROP COLUMN.
    https://github.com/miguelgrinberg/Flask-Migrate/issues/17
- Note that SQLiteStudio can do this, but you need to commit it.
- You can manually edit the Alembic commands to use this method:

    with op.batch_alter_table('weights') as batch_op:  # RNC
        batch_op.drop_column('weight_kg')

    http://stackoverflow.com/questions/30394222/why-flask-migrate-cannot-upgrade-when-drop-column

===============================================================================
SQLAlchemy
===============================================================================

GENERAL

- http://alextechrants.blogspot.co.uk/2013/11/10-common-stumbling-blocks-for.html

DECIMAL / SQLite

- http://stackoverflow.com/questions/10355767/how-should-i-handle-decimal-in-sqlalchemy-sqlite
  ... works fine without, though.

===============================================================================
GENERAL TASK DESIGN
===============================================================================

- Store config + results in (same?) database.
  Use this as the primary data store for everything. Much simpler.
  Flush/commit whenever important.
  Mark config as "frozen" once run.

- Check database migration version is correct.
  http://stackoverflow.com/questions/24431366/getting-alembic-database-version-programmatically
  http://alembic.readthedocs.org/en/latest/api/runtime.html

- SQLite3 is built in.
  http://stackoverflow.com/questions/19530974/how-can-i-install-sqlite3-to-python

- GUI: tkinter is standard, fast, and OK.

- Using twisted with tkinter:
    - direct support in twisted
      http://twistedmatrix.com/documents/13.2.0/core/howto/choosing-reactor.html#auto16
      http://stackoverflow.com/questions/18264363/twisted-tcp-server-with-a-tkinter-gui

===============================================================================
TWISTED + GUI
===============================================================================

tkinter
- can hack in support for Python 3 (same code, more or less, works as for Py2)
- BUT modal dialogs (using grab_set) block the Twisted TCP/IP reactor
    ... also true of tkinter.filedialog.askopenfilename
    ... STILL POSSIBLE TO WORK AROUND THIS.
        WHILE TASK IS RUNNING, DISALLOW, or allow modeless version only.
    OR
    - you could use a version without wait_window(), which allows the main
      message loop (including Twisted) to run, though requires addition of a
      callback. So not really modal, but effectively the same from the user's
      point of view (stealing and keeping the focus).
    - and you can prevent file dialogs from blocking the root window
      http://stackoverflow.com/questions/16105998/tkinter-how-to-open-multiple-filedialogs
    BASICALLY
    - code in dialogues is being called FROM the underlying message loop, so
      it can't pause without pausing that message loop
    - ... so modeless (in the sense of non-blocking) only during TCP/IP ops

- The term modal...
  does it imply BOTH (a) prevents input elsewhere, and (b) blocks actions of
  caller? Obviously, normally those go together. But we divorce them in this
  situation.

SO: perhaps we're safer with THREADS.
In which case, we could look at PyQt (with its serial port and TCP/IP methods).
SEE BELOW.

Other tkinter
- https://www.daniweb.com/programming/software-development/code/487653/access-the-clipboard-via-tkinter

===============================================================================
Installing PyQt / PySide2
===============================================================================
NOTE GPL LICENSE FOR PYQT (LGPL for Qt itself)
... LGPL for PySide
    https://github.com/PySide/pyside2-setup

-------------------------------------------------------------------------------
PyQt -- easy but GPL
-------------------------------------------------------------------------------
http://www.gnu.org/licenses/gpl-faq.html#DoesTheGPLAllowMoney

$ sudo apt-get install python3-pyqt5

-------------------------------------------------------------------------------
PySide2 = PySide for Qt5  -- LGPL but in development
-------------------------------------------------------------------------------
https://github.com/PySide/pyside2/wiki/Dependencies

$ sudo apt-get install build-essential git cmake qt5-default libxml2 libxslt
$ sudo apt-get install qttools5-dev-tools libqt5clucene5 libqt5concurrent5 libqt5core5a libqt5dbus5 libqt5designer5 libqt5designercomponents5 libqt5feedback5 libqt5gui5 libqt5help5 libqt5multimedia5 libqt5network5 libqt5opengl5 libqt5opengl5-dev libqt5organizer5 libqt5positioning5 libqt5printsupport5 libqt5qml5 libqt5quick5 libqt5quickwidgets5 libqt5script5 libqt5scripttools5 libqt5sql5 libqt5sql5-sqlite libqt5svg5 libqt5test5 libqt5webkit5 libqt5widgets5 libqt5xml5 libqt5xmlpatterns5 libqt5xmlpatterns5-dev

-------------------------------------------------------------------------------
PySide = PySide for Qt4 -- LGPL
-------------------------------------------------------------------------------
http://wiki.qt.io/PySide
http://wiki.qt.io/Differences_Between_PySide_and_PyQt
https://wiki.qt.io/PySide_Pitfalls
http://rfk.id.au/blog/entry/hatchet-hack-frozen-pyside-apps/  # !!!

$ sudo apt-get install qt-sdk
$ pip install pyside  # slow!




http://stackoverflow.com/questions/22992331/pyside-pyserial-and-threading-causes-segfault

http://eli.thegreenplace.net/2009/08/07/a-live-data-monitor-with-python-pyqt-and-pyserial

===============================================================================
MAIN NOTES
===============================================================================

Overall software design
- Temptation is to use Twisted for the serial/network comms.
  However,
  (a) we have to support blocking sockets; I've previously done this with plain
      old sockets. Twisted's method is to say "put it in a thread and convert
      the result to a Deferred";
      http://twistedmatrix.com/documents/12.1.0/core/howto/gendefer.html#auto5
  (b) If we want a GUI, we can't use Tkinter: modal dialogues, including system
      ones that we can't rewrite, block the Twisted event loop. And Twisted
      has poor support for Qt, etc.
  Therefore, let's use threads.

Thread design
- Main thread is the GUI.
- The Whisker task will want to do blocking requests via the immediate socket.
  So, the task and the immediate socket together constitute a second sensible
  thread.
- The Whisker task will need to be notified of events arriving via the main
  socket. Have the task thread check the main socket for data? Have a separate
  thread manage the main socket and post events to the Whisker task thread?
  Run all Whisker task functions as callbacks from the main socket (like the
  C++ version)?
  Probably best like this:
    - GUI thread creates Whisker task thread
    - Whisker task thread creates main socket listening thread
    - main socket listening thread sends signal to Whisker task thread slot
    - Whisker task thread slot operates in blocking mode over immediate socket
- Serial port code is sensible as another thread, or two for read/write
  separation.
- We could use Python threads or Qt threads. However, an argument can be made
  as follows:
  - We don't want GUI operations blocking socket/serial operations.
  - We don't want any risk that that can happen, i.e. no special modifications
    to the GUI code.
  - Therefore, tkinter + twisted (using twisted's support for tkinter) won't
    work well, since GUI dialogues can block twisted.
  - Therefore, threads.
  - Therefore, no particular need to use Twisted, though we could.
  - Twisted support for Qt is not fantastic at present.
  - Qt is a good GUI.
  - Therefore, Qt with its own networking code makes sense.
  - Therefore, Qt threads.
- "Subclass QThread" or "give a QObject to a QThread" debate:
  - http://stackoverflow.com/questions/6783194
  - https://blog.qt.io/blog/2010/06/17/youre-doing-it-wrong/
  - http://doc.qt.io/qt-5/qthread.html
  - https://www.qtdeveloperdays.com/sites/default/files/David%20Johnson%20qthreads.pdf  # noqa
  - http://stackoverflow.com/questions/20324804  # particularly clear

GUI design
- Qt, as above.
- Python interfaces are PyQt and PySide.
  - PyQt supports Qt5 (not yet fully in PySide, though in development), but
    that's not critical.
  - PySide is the more open (LGPL, matching Qt); PyQt is GPL.
- Therefore, Qt4 + PySide.

Network design
- Qt networking, as above, for simplicity.

Serial design
- PySerial: https://pythonhosted.org/pyserial/
- Efficient blocking:
  http://stackoverflow.com/questions/24764431
- Perfectly possible to have a reader thread and a writer thread:
    http://stackoverflow.com/questions/8796800
  ... and, moreover, using the same serial port instance:
    http://stackoverflow.com/questions/14487151
  On the other hand, also possible to use the reader thread to send... but that
  requires a sufficiently small timeout (i.e. is value-dependent; not ideal).

Serial debugging
$ socat -d -d - pty,raw,echo=0

Signals -> slots
- Signals must be class attributes, not instance attributes
  http://stackoverflow.com/questions/2970312
- Objects are passed through signals by reference. So beware across threads.
  http://stackoverflow.com/questions/11675307
- Naming conventions:
  - Qt internals have signals like threadobject.finished; that might be
    something to mimic.
  - Some aspects of Qt (I think nothing I'm using) do autoconnect to slots
    beginning "on_". That might be something to mimic or avoid.
  - Prefixing everything with "sig_" and "slot_" is just ugly.
  - Qt example uses
        signal = past-tense verb, e.g. valueChanged
        slot = infinitive verb, e.g. setValue
    http://doc.qt.io/qt-5/signalsandslots.html
- An AutoConnection determines whether it will behave as a DirectConnection
  or a QueuedConnection when the signal is emitted.
  http://stackoverflow.com/questions/20752154
- Curious problem with derived classes: my question at
    http://stackoverflow.com/questions/34125065
  and existing bug report discovered later at
    https://bugreports.qt.io/browse/PYSIDE-249
  ... the upshot being: DO NOT USE THE @Slot() DECORATOR IN A BASE CLASS THAT
  YOU MIGHT WISH TO DERIVE FROM under PySide in a multithreaded environment.
  It is fine to omit the decorator entirely; everything will still work.
  THUS: all instances of "@Slot()" decorator removed.

Command-line options to Qt
- http://doc.qt.io/qt-5/qapplication.html#QApplication
- http://stackoverflow.com/questions/11713006

Object ownership
- Qt objects should be *owned*, or they can get garbage-collected.
  Qt objects with a parent are owned by Qt; ones without by Python.
  - http://camelot.readthedocs.org/en/latest/advanced/development.html
  The parent also sets the layout.
  - http://stackoverflow.com/questions/25450598
- However, objects to be moved to a thread with moveToThread() can't have a
  parent (helpfully: "Cannot move objects with a parent").
- Gotchas: http://enki-editor.org/2014/08/23/Pyqt_mem_mgmt.html

Database ORM
- SQLAlchemy is the obvious choice for Python.
- Note also that under C++/Qt there are others, e.g.
    http://www.qxorm.com/ (GPL)
    http://www.codesynthesis.com/products/odb/
    https://en.wikipedia.org/wiki/List_of_object-relational_mapping_software
- While the Qt framework is easily portable to C++, the ORM is less so.

Database thread safety
- http://docs.sqlalchemy.org/en/latest/orm/contextual.html
- http://stackoverflow.com/questions/6297404/multi-threaded-use-of-sqlalchemy

Database migrations
- Using Alembic.
- Custom code to number autogenerated revisions.
- Note that Alembic looks in sqlite_master (in the system catalogue) of SQLite
  databases; if you manually DROP a table, the table creation SQL will linger,
  which can be a bit confusing.
- Alembic will fail to generate the proper syntax for a DROP COLUMN
  pseudo-operation in SQLite. Use this:
  http://alembic.readthedocs.org/en/latest/batch.html

Database notes
- Note that SQLAlchemy automatically notices changes to objects in sessions;
  no need to save explicitly (as with Django's .save(), just to commit:
  http://docs.sqlalchemy.org/en/latest/orm/tutorial.html

Config files
- Static config files are well handled by INI files or similar, or one can use
  JSON for more structured work.
- However, for tasks, we want dynamic configuration; i.e. the user can edit.
  We also want the config to be accessible along with results.
  Options for information storage include
    - registry, under Windows
    - plain-text disk files
    - database
  In current C++ task work, that involves duplication of the config into the
  results database (which is not always complete, and not easily reversible).
  Therefore, better to have the config in the results database.
  Flag it with "used" if it has results pointing to it (or similar), so that
  it can be re-used (maybe with a separate "session" table giving session
  number and foreign key to config) or copied but not modified once it's been
  used.
- "Singleton" records: options include
  - a table with name (unique)/type/boolvalue/textvalue/datevalue/numericvalue
    fields
  - a table with a single row and a unique primary key that always takes the
    value 1 (or similar).
- What about hardware config?
    - Exporting/importing: can use sqlite3's ".dump" command, e.g.
        $ sqlite3 my_database.db
        sqlite> .output mydump.sql
        sqlite> .dump
        sqlite> .quit
    - ... which you can re-import with
        $ sqlite3 new_database.db < mydump.sql
        or
        $ sqlite3 new_dataase.db
        sqlite> .read mydump.sql
    - ... or Sqliteman (http://sqliteman.yarpen.cz/), which has a
      Database > Dump command on its menus.
- All these things (apart from the registry) need passing in to the program
  somehow. Simplest way would be a single environment variable pointing to
  the database configuration. Or, more generically, a single environment
  variable leading to an SQLAlchemy configuration.
  SQLAlchemy uses a single string for its database URL, which can include
  passwords.
  Perfectly reasonable to use an environment variable. So let's do that.

Editing objects in a dialog
- How about: The dialog should not have any commit/rollback within it.
  If that principle is respected, you can build a hierarchy of dialogue boxes,
  and the lowest-level can still cancel changes produced by others.
- Better: the dialog should encapsulate its changes in a nestable transaction.
  Then all levels can implement OK/cancel.

Distribution/installation
- See http://www.pyinstaller.org/

Signal processing for weight, if required
- See http://www.swharden.com/blog/2009-01-21-signal-filtering-with-python/



Physical device naming convention
- "USB controller" = MBRose WS-2/001 RS232-to-USB interface
- "Reader" = MBRose BW-1/001 integrated load cell scale RFID reader

Physical installation
- mains -> female connector (!) -> "12V OUT" (!) on USB controller
- USB controller computer
- USB controller "RS232(1)" port (RJ45 connector) to "RFID" port on Reader
- USB controller "RS232(2)" port (RJ45 connector) to "SCALE" port on Reader
- Antenna to "ANT" port on Reader (this is the only 6-wire connector)

Lights
- USB controller "12V" button lights up when power on
- USB controller "RFID" light (next to power switch) does nothing and probably
  relates only to an RFID antenna plugged into the BNC connector on the USB
  controller.
- USB controller "USB 5V" LED lights up when computer connected
- USB controller "Status 1-4" LEDs flash during computer/device serial comms
- Reader "RFID" blue LED lights up when plugged into USB controller
- Reader "ANT" green LED lights up when (a) reader is in continuous reading
  mode AND (b) tag is being read (i.e. it flashes for a tag read).


Insides
- Reader "ANT" light looks to be controlled by the RFID PCB.
  Not yet on.
- Chips:
    Atmel ATMEGA8L 8AU 1431D
    ... this? http://www.atmel.com/images/atmel-2486-8-bit-avr-microcontroller-atmega8_l_datasheet.pdf
        = ATMega8L-8AU CPU/serial port controller with built-in EEPROM
    NXP HTRC110 01T CEH04711 Tn614340
    ... http://www.nxp.com/documents/data_sheet/037031.pdf
        = 125 kHz reader chip for transponders
    L4931 C50
    ... dull; http://www.st.com/web/catalog/sense_power/FM142/CL1015/SC312/SS1733/PF259704
- But what's the full protocol?
    Google "continuous read stopped" rfid
    http://usa.balluff.com/manuals/Balluff_EMS%20RFID(Former%20Datalogic)/BIS_ABx_Protocol_Manual.pdf

Software side of installation

    $ lsusb

        Bus 002 Device 026: ID 0557:2011 ATEN International Co., Ltd UC-2324 4xSerial Ports [mos7840]

    $ ls /dev/tty*

        /dev/ttyUSB0
        /dev/ttyUSB1
        /dev/ttyUSB2
        /dev/ttyUSB3

    $ dmesg | grep tty

        [175462.115899] usb 2-1.7.4: Moschip 7840/7820 USB Serial Driver converter now attached to ttyUSB0
        [175462.117142] usb 2-1.7.4: Moschip 7840/7820 USB Serial Driver converter now attached to ttyUSB1
        [175462.118280] usb 2-1.7.4: Moschip 7840/7820 USB Serial Driver converter now attached to ttyUSB2
        [175462.119774] usb 2-1.7.4: Moschip 7840/7820 USB Serial Driver converter now attached to ttyUSB3

    $ sudo minicom -s

        ... pick /dev/ttyUSB0, and when you press Enter, light 1 flashes on the USB controller
        DO NOT USE STUFF LIKE THIS:
            socat - /dev/ttyUSB0
            stty -F /dev/ttyUSB1 eol ^J 9600 parenb -parodd
            stty -F /dev/ttyUSB1 -a
            socat - /dev/ttyUSB1
        ... BECAUSE SOCAT IS LINE-BASED, NOT CHARACTER BASED; i.e. it only
        transmits when you press Enter, and then it may send an EOL character,
        and it turns out that can terminate the RFID detection cycle.

        Best (or at least, good) terminal emulators:
            Linux: sudo minicom -s
            Windows: PuTTY
            
        In one command:
        
    $ minicom  --device /dev/ttyUSB1 --baudrate 9600  # untested; note also --noinit option; would it make a difference?

    When the RFID is communicating, 'x' resets (yielding a status message of
    "MULTITAG-125 01"), and 'c' starts the reader.

    Another useful monitoring tool:
        $ sudo apt-get install jpnevulator
        $ jpnevulator --read --tty=/dev/ttyUSB0 --ascii --control
        $ jpnevulator --read --tty=/dev/ttyUSB1 --ascii --control

    Better still:
        $ sudo modprobe usbmon
        $ sudo wireshark &
            Now use "usbmon2" to monitor bus 2, etc.
            Look at aspects of a packet, right-click, and use "Apply as filter"
            ... e.g. URB_BULK packets
            Like this:
            Right-click on "Data length (bytes)" in the packet, then "Apply as column"
            WATCHING DATA TO/FROM EVERYTHING:
                usb.bus_id == 2 && usb.device_address == 11 && usb.transfer_type == 0x03 && usb.data_len > 0
            WATCHING DATA TO/FROM RFID:
                usb.bus_id == 2 && usb.device_address == 11 && usb.transfer_type == 0x03 && usb.data_len > 0 && usb.endpoint_number.endpoint == 2
            WATCHING DATA TO/FROM BALANCE:
                usb.bus_id == 2 && usb.device_address == 11 && usb.transfer_type == 0x03 && usb.data_len > 0 && usb.endpoint_number.endpoint == 4
            WATCHING EVERYTHING TO/FROM BALANCE:
                usb.bus_id == 2 && usb.device_address == 11 && usb.endpoint_number.endpoint == 4

    Of note, minicom sends 0x4f ('0') then 0x46 ('F') when it starts comms. Is that important?

    Watch output:
        $ ./run.py -v 2>&1 | grep rfid0

    Making a fake serial port with keyboard input producing LF line endings (\n):
        $ socat - pty,raw,echo=0
    Making a fake serial port with keyboard input producing CR+LF line endings
    for the remote's benefit (\r\n):
        $ socat - pty,raw,echo=0,crnl
    Talking to a real serial port with keyboard input producing CR line endings:
        $ socat - /dev/ttyUSB1,cr

    Note in passing that QSerialPort is part of Qt5, but not standard Qt4.
    
Concepts around detecting mass from an identified animal

- Balances and RFID readers are paired.
- We can't in any way guarantee an absolutely simultaneous mass + RFID; that is
  highly unlikely. And the RFID system doesn't allow us to say "what's the RFID
  now?" -- it just sends a stream of RFIDs.
- We could set an RFID_EFFECTIVE_TIME (e.g. 1 second); if a stable mass is
  received at the balance, then the identified animal is the one owning the
  RFID that was MOST RECENTLY received at the relevant receiver, as long as
  that was within this time.
- Storing all RFID events is likely to generate quite a lot of data, as
  bursts are generated (visual estimation: 10 Hz? More?) when the RFID is next
  to the antenna.
  Is there an obvious alternative?
  - Have an RFID "time span"? RFID, first_detected, last_detected?
    ... for example: if a tag is observed, then if it wasn't the last tag
        observed, start a new record, with first_detected = last_detected = now
    ... and if it hasn't been observed for more than RFID_EFFECTIVE_TIME
        seconds, start a new record
    ... but otherwise (if that same tag was the last one observed at that
        reader, and was observed within the last RFID_EFFECTIVE_TIME seconds)
        then amend the last_detected field instead.
    Then the balance's algorithm would be:
    ... When a mass is received, then if there's an RFID timespan for the
        relevant reader whose last_detected field is within RFID_EFFECTIVE_TIME
        seconds, then call that a hit.

- There is a clear dependence of balances/masses on RFIDs, and not the other
  way around. (A "free-floating" mass is useless in this context; a
  located RFID is still useful.) So we can have the balance store an FK to
  RFID reader, etc.
  
- We get a storage-heavy mess if we store RFID reader/balance names all over
  the place; better to store an FK only. But that means we must prevent
  deletion of config objects that have been used for real data. We use a 'keep'
  flag for this. Instead, the user can disable things.
  (Note that the QGroupBox is happier with 'enabled' than 'disabled', so we'll
  go with that.)
  
- Alembic/SQLite nuisance here: http://alembic.readthedocs.org/en/latest/batch.html

===============================================================================
TO DO
===============================================================================

*** physical balance test
*** balance weighing code
*** PyInstaller

*** test RFID recording logic
*** test weighing logic
*** test that "used" RFID/balance devices can't be deleted, and buttons reflect that
